#!/usr/bin/python
# Copyright (c) 2015 Princeton University
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of Princeton University nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#####################################################################
#  Filename      : pitonstream
#  Version       : 1.0
#  Created On    : 2016-06-10
#  Author        : Alexey Lavrov
#  Company       : Princeton University
#  Email         : openpiton@princeton.edu
#
#  Description   : top level script for streaming data from PC to
#                  OpenPiton proto            
#
#####################################################################

import time, re, sys, os, serial, shlex, subprocess
import make_mem_map as mmm
import image2stream as i2s
from optparse import OptionParser
DEBUG = False
INFO = False
from fpga_lib import *

class bcolors:
    PASSED = '\033[92m'
    TIMEOUT = '\033[93m'
    FAILED = '\033[91m'
    ENDC = '\033[0m'


FLOG_NAME = os.path.join(MODEL_DIR, "uart_piton.log")

CFG_DONE_KEY        = "DONE"
TEST_PASSED_KEY     = "PASSED"
TEST_FAILED_KEY     = "FAILED"
TEST_TIMEOUT_KEY    = "TIMEOUT"

CFG_DONE_EVENT      = 0
TEST_PASSED_EVENT   = 1
TEST_FAILED_EVENT   = 2
TEST_TIMEOUT_EVENT  = 3

MEM_SIZE = 33554432 # 1 GB = 32B * 33554432

FNULL = open(os.devnull, 'w')

def usage():
    print >> sys.stderr
    print >> sys.stderr, "Usage:\npitonstream -b <board type> -f <filename> [--ustr]",
    print >> sys.stderr
    print >> sys.stderr, "\n       -b, --board  <board_type>"
    print >> sys.stderr, "              Name of a supported Xilinx's development board. Available options are:"
    print >> sys.stderr, "                  nexys4ddr*"
    print >> sys.stderr, "                  vc707"
    print >> sys.stderr, "                  genesys2"
    print >> sys.stderr, "                  nexysVideo"
    print >> sys.stderr, "\n                  * current configuration of design doesn't fit on this board"
    print >> sys.stderr, "\n       -f, --file <filename>"
    print >> sys.stderr, "              File name with test names. If option --ustr is not specified,"
    print >> sys.stderr, "              they should be assembly test names, otherwise list of generated"
    print >> sys.stderr, "              .ustr files"
    print >> sys.stderr, "\n       --ustr"
    print >> sys.stderr, "              Specifies that test names in the file should be treated as .ustr file names"
    print >> sys.stderr, "\n       -h, --help"
    print >> sys.stderr, "              Display this help message and exit"
    print >> sys.stderr, "\n"

def checkCmdOptions(options):
    if options.help:
        usage()
        return False

    if options.fname == None:
        print >> sys.stderr, "ERROR: File with assembly test is not given"
        usage()
        return False

    # Check if design is specified 
    # (It has a default value so always should be)
    if (options.design == None):
        print >> sys.stderr, "ERROR: invalid parameters"
        usage()
        return False

    # Check if design module is found
    design_data = find_design_block(options.design)
    if (design_data == None):
        print >> sys.stderr, "ERROR: Could not find design module '" + options.design + "'"
        usage()
        return False

    # Check if board is supported 
    if not options.board:
        print >> sys.stderr, "ERROR: Board name is not provided"
        usage()
        return False

    # Check if board is supported
    if (options.board not in design_data["BOARDS"]):
        print >> sys.stderr,  "ERROR: unsupported board"
        usage()
        return False

    if options.storage not in ["bram", "ddr", None]:
        print >> sys.stderr, "ERROR: unexpected storage type"
        usage()
        return False

    return True

def configureUART():
    print >> sys.stderr, "UART will be configured for %d baud rate" % UART_BAUD_RATE
    ser = serial.Serial (
        port='/dev/ttyS0',
        baudrate=UART_BAUD_RATE,
        bytesize=serial.EIGHTBITS,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE
    )
    return ser

def writeSTDOUT(s):
    sys.stdout.write(s)
    sys.stdout.flush()

def pollUART(ser):
    has_key = False
    rdata_all = ""
    while True:
        if ser.inWaiting() > 0:
            rdata = ser.read(ser.inWaiting())
            rdata_all += rdata
            if CFG_DONE_KEY in rdata_all:
                event = CFG_DONE_EVENT
                key_index = rdata_all.index(CFG_DONE_KEY)
                rdata_all = rdata_all[:key_index]
                break
            elif TEST_PASSED_KEY in rdata_all:
                event = TEST_PASSED_EVENT
                key_index = rdata_all.index(TEST_PASSED_KEY)
                rdata_all = rdata_all[:key_index]
                break
            elif TEST_FAILED_KEY in rdata_all:
                event = TEST_FAILED_EVENT
                key_index = rdata_all.index(TEST_FAILED_KEY)
                rdata_all = rdata_all[:key_index]
                break
            elif TEST_TIMEOUT_KEY in rdata_all:
                event = TEST_TIMEOUT_EVENT
                key_index = rdata_all.index(TEST_TIMEOUT_KEY)
                rdata_all = rdata_all[:key_index]
                break
    writeSTDOUT("%s\n" % rdata_all)
    return event

def loadTest(tname, ser):
    prev_dir = os.getcwd()
    os.chdir(MODEL_DIR)

    try:
        num_lines = sum(1 for line in open(tname))
    except IOError:
        print >> sys.stderr, "ERROR: file %s does not appear to exist" % tname
        return 1

    f = open(tname, 'r')

    writeSTDOUT("Loading a test...\n")
    line_cnt = 0
    prev_perc = 0
    for line in f:
        line_striped = line.strip()
        ser.write(line_striped.decode("hex"))
        line_cnt += 1 
        perc = 100*line_cnt/num_lines
        if (perc > prev_perc):
            sys.stdout.write("%d%%\r" % perc)
            sys.stdout.flush()
            prev_perc = perc

    writeSTDOUT("\nTEST OUTPUT >>>\n")
    f.close()

    os.chdir(prev_dir)
    return 0

def exitProgram(exit_code, ser, flog):
    writeSTDOUT("\nExiting...\n\n")
    flog.close()
    ser.close()
    exit(exit_code)

def processKeyboardInterrupt(ser, flog):
    writeSTDOUT("\nProgram was interrupted\n")
    exitProgram(1, ser, flog)
    return

def addrDataFromC(fname):
    f = open(fname, 'r')
    cont = f.read()
    f.close()

    # Make addr:data map for a test
    test_addr_data_map = dict()
    test_sec_list = re.findall(r"uint64_t MI_[0-9a-f]+.*\n[^}]+}", cont)
    printInfo("Found %d sections" % len(test_sec_list))
    for sec in test_sec_list:
        m = re.search(r"MI_([0-9a-f]{16})", sec);
        if m == None:
            print >> sys.stderr, "Can't extract section address"
            return None
        sec_addr = int(m.group(1), 16)
        dw_list = re.findall(r"0x[0-9a-f]{16}", sec)
        dw_cnt = 0
        for dw in dw_list:
            addr = sec_addr + dw_cnt*8
            test_addr_data_map[addr] = dw[2:]
            dw_cnt += 1

    return test_addr_data_map

def compileASMTest(tname, uart_div_latch, st_brd, flog):
    prev_dir = os.getcwd()
    os.chdir(MODEL_DIR)
    printInfo("Compiling %s" % tname)
    # Run midas only to get mem.image file
    rv = runMidas(tname, uart_div_latch, flog)
    if rv != 0:
        return rv

    # Generate mbfw_diag_memimage.c file with all uncompressed sections for a test
    printInfo("Compiling C test from mem.image for %s" % tname)
    rv = runGenmemimage(tname, flog)
    if rv != 0:
        return rv

    # Extract sections and their size from C generated test
    printInfo("Creating addr:data map for the test")
    addr_data_map = addrDataFromC("mbfw_diag_memimage.c")
    if rv == None:
        return None

    # Since we are using an existent synthesized mapping, we have to check
    # that all sections of new tests are mapped
    rv = isTranslatorOK(addr_data_map, flog)
    if not rv:
        print >> sys.stderr, "ERROR: Can't use existent storage_addr_trans.v for %s" % tname
        return 1
    
    # Use available functions in make_mem_map.py to generate sections
    # and map them to contiguos memory
    printInfo("Extracting test sections") #NOTE: can be optimized and extracted from mem.image
    test_sections = mmm.memTestData(st_brd, addr_data_map, flog)
    # generates bram_map.log as one of outputs
    rv = mmm.mapToBram(test_sections, st_brd) #TODO: change mem_size for each board (although the limit is always never reached)
    if rv != 0:
        return 1

    # Generate universal stream for loading on FPGA from BRAM mapping
    # outputs test.ustr
    i2s.makeStreamFile("bram_map.log")

    os.chdir(prev_dir)
    return 0

def setParserOptions(parser):
    parser.add_option("-f", "--file", dest="fname", action="store", help="Name of an input file with list of assembly tests")
    parser.add_option("-s", "--storage", dest="storage", action="store", default="ddr")
    parser.add_option("-b", "--board", dest="board", action="store")
    parser.add_option("-d", "--design", dest="design", action="store", default="system")
    parser.add_option("--ustr", dest="ustr", action="store_true", default=False)
    parser.add_option("-h", "--help", dest="help", action="store_true", default=False)

    return parser

def printDebug(s):
    if DEBUG:
        print >> sys.stderr, "DEBUG: " + s

def printInfo(s):
    if INFO:
        print >> sys.stderr, "INFO: " + s

def main():
    ser = configureUART()
    flog = open(FLOG_NAME, 'w')

    parser = OptionParser(add_help_option=False)
    parser = setParserOptions(parser)
    (options, args) = parser.parse_args()

    # Check input options
    rv = checkCmdOptions(options)
    if not rv:
        exitProgram(1, ser, flog)
    
    if options.storage == "bram":
        st_brd = StorageBoard("bram", options.board)

    if options.storage == "ddr":
        st_brd = StorageBoard("dmw", options.board)
    
    # Get list of tests and board configuration
    tests = getTestList(options.fname, flog, options.ustr)
    printDebug(str(tests))
    # Calculate UART divider latch before test compilation
    design_data = find_design_block(options.design)
    uart_div_latch = calcUARTLatch(design_data, options.board)


    # Wait until FPGA is configure
    writeSTDOUT("Press reset button on FPGA\n")
    writeSTDOUT("Waiting...\n")
    while True:
        try:
            event = pollUART(ser)
            if event == CFG_DONE_EVENT:
                writeSTDOUT("Configuration is complete\n\n")
                break
        except KeyboardInterrupt:
            processKeyboardInterrupt(ser, flog)
            return

    # Main test loop
    test_num = len(tests)
    test_cnt = 0
    for tname in tests:
        test_cnt += 1
        print >> sys.stderr, "Running %s: %d out of %d test" % (tname, test_cnt, test_num)
        # Compile .s tests to get .ustr
        if options.ustr == False:
            rv = compileASMTest(tname, uart_div_latch, st_brd, flog)
            if rv != 0:
                print >> sys.stderr, "ERROR: Test compilation failed"
                print >> sys.stderr, "ERROR: Skipping %s" % tname
                print >> sys.stderr, "ERROR: See %s for more information\n\n" % FLOG_NAME
                continue
            ustr_name = "test.ustr"
        # Use pregenerated .ustr files
        else:
            ustr_name = tname

        try:
            rv = loadTest(ustr_name, ser)
            if rv != 0:
                print >> sys.stderr, "ERROR: Can not upload a stream. Skipping %s" % tname
                continue
            event = pollUART(ser)
            
            if event == TEST_PASSED_EVENT:
                writeSTDOUT("<<< END OF TEST OUTPUT\n")
                writeSTDOUT("%s : %sPASSED%s\n\n" % (tname, bcolors.PASSED, bcolors.ENDC))

            if event == TEST_FAILED_EVENT:
                writeSTDOUT("<<< END OF TEST OUTPUT\n")
                writeSTDOUT("%s : %sFAILED%s\n\n" % (tname, bcolors.FAILED, bcolors.ENDC))

            if event == TEST_TIMEOUT_EVENT:
                writeSTDOUT("<<< END OF TEST OUTPUT\n")
                writeSTDOUT("%s : %sTIMEOUT%s\n\n" % (tname, bcolors.TIMEOUT, bcolors.ENDC))             
        except KeyboardInterrupt:
            processKeyboardInterrupt(ser, flog)
            return

    writeSTDOUT("\n==============================\n")
    writeSTDOUT("All tests finished\n")
    exitProgram(0, ser, flog)

if __name__ == '__main__':
    main()